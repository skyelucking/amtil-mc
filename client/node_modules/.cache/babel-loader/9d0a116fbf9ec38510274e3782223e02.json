{"ast":null,"code":"import { clone, getMerge, isProduction } from \"@rpldy/shared\";\nimport { PROXY_SYM, STATE_SYM } from \"./consts\";\nimport { isProxiable, isProxy } from \"./utils\";\nvar mergeWithSymbols = getMerge({\n  withSymbols: true,\n  predicate: function predicate(key) {\n    return key !== PROXY_SYM && key !== STATE_SYM;\n  }\n});\n\nvar getIsUpdateable = function (proxy) {\n  return isProduction() ? true : proxy[STATE_SYM].isUpdateable;\n};\n\nvar setIsUpdateable = function (proxy, value) {\n  if (!isProduction()) {\n    proxy[STATE_SYM].isUpdateable = value;\n  }\n};\n\nvar deepProxy = function (obj, traps) {\n  var proxy;\n\n  if (isProxiable(obj)) {\n    if (!isProxy(obj)) {\n      obj[PROXY_SYM] = true;\n      proxy = new Proxy(obj, traps);\n    }\n\n    Object.keys(obj).forEach(function (key) {\n      obj[key] = deepProxy(obj[key], traps);\n    });\n  }\n\n  return proxy || obj;\n};\n\nvar unwrapProxy = function (proxy) {\n  return isProxy(proxy) ? clone(proxy, mergeWithSymbols) : proxy;\n};\n/**\n * deep proxies an object so it is only updateable through an update callback.\n * outside an updater, it is impossible to make changes\n *\n * This a very (very) basic and naive replacement for Immer\n *\n * It only proxies simple objects (not maps or sets) and arrays\n * It doesnt create new references and doesnt copy over anything\n *\n * Original object is changed!\n *\n * DOESNT support updating state (wrapped seperately) that is set as a child of another state\n * @param obj\n * @returns {{state, update, unwrap}}\n */\n\n\nexport default (function (obj) {\n  var traps = {\n    set: function set(obj, key, value) {\n      if (getIsUpdateable(proxy)) {\n        obj[key] = deepProxy(value, traps);\n      }\n\n      return true;\n    },\n    get: function get(obj, key) {\n      return key === PROXY_SYM ? unwrapProxy(obj) : obj[key];\n    },\n    defineProperty: function defineProperty() {\n      throw new Error(\"Simple State doesnt support defining property\");\n    },\n    setPrototypeOf: function setPrototypeOf() {\n      throw new Error(\"Simple State doesnt support setting prototype\");\n    },\n    deleteProperty: function deleteProperty(obj, key) {\n      if (getIsUpdateable(proxy)) {\n        delete obj[key];\n      }\n\n      return true;\n    }\n  };\n\n  if (!isProduction() && !isProxy(obj)) {\n    Object.defineProperty(obj, STATE_SYM, {\n      value: {\n        isUpdateable: false\n      },\n      configurable: true\n    });\n  }\n\n  var proxy = !isProduction() ? deepProxy(obj, traps) : obj;\n  return {\n    state: proxy,\n    update: function update(fn) {\n      if (!isProduction() && getIsUpdateable(proxy)) {\n        throw new Error(\"Can't call update on State already being updated!\");\n      }\n\n      try {\n        setIsUpdateable(proxy, true);\n        fn(proxy);\n      } finally {\n        setIsUpdateable(proxy, false);\n      }\n\n      return proxy;\n    },\n    unwrap: function unwrap(entry) {\n      return entry ? //simply clone the provided object (if its a proxy)\n      unwrapProxy(entry) : //unwrap entire proxy state\n      isProxy(proxy) ? unwrapProxy(proxy) : proxy;\n    }\n  };\n});\nexport { isProxy, unwrapProxy as unwrap };","map":{"version":3,"sources":["C:/Users/lucki/Desktop/ClassCodeProjects/amtil-mc/node_modules/@rpldy/simple-state/lib/esm/createState.js"],"names":["clone","getMerge","isProduction","PROXY_SYM","STATE_SYM","isProxiable","isProxy","mergeWithSymbols","withSymbols","predicate","key","getIsUpdateable","proxy","isUpdateable","setIsUpdateable","value","deepProxy","obj","traps","Proxy","Object","keys","forEach","unwrapProxy","set","get","defineProperty","Error","setPrototypeOf","deleteProperty","configurable","state","update","fn","unwrap","entry"],"mappings":"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","sourcesContent":["import { clone, getMerge, isProduction } from \"@rpldy/shared\";\nimport { PROXY_SYM, STATE_SYM } from \"./consts\";\nimport { isProxiable, isProxy } from \"./utils\";\nvar mergeWithSymbols = getMerge({\n  withSymbols: true,\n  predicate: function predicate(key) {\n    return key !== PROXY_SYM && key !== STATE_SYM;\n  }\n});\n\nvar getIsUpdateable = function (proxy) {\n  return isProduction() ? true : proxy[STATE_SYM].isUpdateable;\n};\n\nvar setIsUpdateable = function (proxy, value) {\n  if (!isProduction()) {\n    proxy[STATE_SYM].isUpdateable = value;\n  }\n};\n\nvar deepProxy = function (obj, traps) {\n  var proxy;\n\n  if (isProxiable(obj)) {\n    if (!isProxy(obj)) {\n      obj[PROXY_SYM] = true;\n      proxy = new Proxy(obj, traps);\n    }\n\n    Object.keys(obj).forEach(function (key) {\n      obj[key] = deepProxy(obj[key], traps);\n    });\n  }\n\n  return proxy || obj;\n};\n\nvar unwrapProxy = function (proxy) {\n  return isProxy(proxy) ? clone(proxy, mergeWithSymbols) : proxy;\n};\n/**\n * deep proxies an object so it is only updateable through an update callback.\n * outside an updater, it is impossible to make changes\n *\n * This a very (very) basic and naive replacement for Immer\n *\n * It only proxies simple objects (not maps or sets) and arrays\n * It doesnt create new references and doesnt copy over anything\n *\n * Original object is changed!\n *\n * DOESNT support updating state (wrapped seperately) that is set as a child of another state\n * @param obj\n * @returns {{state, update, unwrap}}\n */\n\n\nexport default (function (obj) {\n  var traps = {\n    set: function set(obj, key, value) {\n      if (getIsUpdateable(proxy)) {\n        obj[key] = deepProxy(value, traps);\n      }\n\n      return true;\n    },\n    get: function get(obj, key) {\n      return key === PROXY_SYM ? unwrapProxy(obj) : obj[key];\n    },\n    defineProperty: function defineProperty() {\n      throw new Error(\"Simple State doesnt support defining property\");\n    },\n    setPrototypeOf: function setPrototypeOf() {\n      throw new Error(\"Simple State doesnt support setting prototype\");\n    },\n    deleteProperty: function deleteProperty(obj, key) {\n      if (getIsUpdateable(proxy)) {\n        delete obj[key];\n      }\n\n      return true;\n    }\n  };\n\n  if (!isProduction() && !isProxy(obj)) {\n    Object.defineProperty(obj, STATE_SYM, {\n      value: {\n        isUpdateable: false\n      },\n      configurable: true\n    });\n  }\n\n  var proxy = !isProduction() ? deepProxy(obj, traps) : obj;\n  return {\n    state: proxy,\n    update: function update(fn) {\n      if (!isProduction() && getIsUpdateable(proxy)) {\n        throw new Error(\"Can't call update on State already being updated!\");\n      }\n\n      try {\n        setIsUpdateable(proxy, true);\n        fn(proxy);\n      } finally {\n        setIsUpdateable(proxy, false);\n      }\n\n      return proxy;\n    },\n    unwrap: function unwrap(entry) {\n      return entry ? //simply clone the provided object (if its a proxy)\n      unwrapProxy(entry) : //unwrap entire proxy state\n      isProxy(proxy) ? unwrapProxy(proxy) : proxy;\n    }\n  };\n});\nexport { isProxy, unwrapProxy as unwrap };"]},"metadata":{},"sourceType":"module"}