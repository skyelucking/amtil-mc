{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nimport isPromise from \"is-promise\";\nimport defaults from \"./defaults\";\nimport { validateFunction, isUndefined } from \"./utils\";\nimport { LESYM, LE_PACK_SYM } from \"./consts\"; //TODO: implement STATS\n\nvar getLE = function (obj) {\n  return obj ? obj[LESYM] : null;\n};\n\nvar getValidLE = function (obj) {\n  var le = getLE(obj);\n\n  if (!le) {\n    throw new Error(\"Didnt find LE internal object. Something very bad happened!\");\n  }\n\n  return le;\n};\n\nvar isLE = function (obj) {\n  return !!getLE(obj);\n};\n\nvar addRegistration = function (obj, name, cb) {\n  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  validateFunction(cb, \"cb\");\n  var le = getValidLE(obj);\n\n  if (!le.options.allowRegisterNonExistent && !~le.events.indexOf(name)) {\n    throw new Error(\"Cannot register for event \".concat(name.toString(), \" that wasn't already defined (allowRegisterNonExistent = false)\"));\n  }\n\n  var namedRegistry = le.registry[name] || [];\n\n  if (!namedRegistry.find(function (r) {\n    return r.cb === cb;\n  })) {\n    //only add same callback for a name once\n    namedRegistry.push({\n      name: name,\n      cb: cb,\n      once: once\n    });\n    le.registry[name] = namedRegistry;\n  }\n\n  return function () {\n    return unregister.call(obj, name, cb);\n  };\n};\n\nvar findRegistrations = function (obj, name) {\n  var registry = getValidLE(obj).registry;\n  return name ? registry[name] ? registry[name].slice() : [] : // $FlowFixMe - flow doesnt know about Array.prototype.flat yet...\n  Object.values(registry).flat();\n};\n\nvar publicMethods = {\n  \"on\": register,\n  \"once\": registerOnce,\n  \"off\": unregister,\n  \"getEvents\": getEvents\n};\n\nvar getPublicMethods = function () {\n  return Object.entries(publicMethods).reduce(function (res, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        m = _ref2[1];\n\n    res[key] = {\n      value: m\n    };\n    return res;\n  }, {});\n}; //using string keys here because can't rely on function names to stay after (babel/webpack) build\n\n\nvar apiMethods = {\n  \"trigger\": trigger,\n  \"addEvent\": addEvent,\n  \"removeEvent\": removeEvent,\n  \"hasEvent\": hasEvent,\n  \"hasEventRegistrations\": hasEventRegistrations,\n  \"assign\": assign\n};\n\nvar createApi = function (target) {\n  return Object.keys(apiMethods).reduce(function (res, name) {\n    res[name] = apiMethods[name].bind(target);\n    return res;\n  }, _objectSpread({\n    target: target\n  }, apiMethods));\n};\n\nvar cleanRegistryForName = function (obj, name) {\n  var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var registry = getValidLE(obj).registry;\n\n  if (registry[name] && (force || !registry[name].length)) {\n    delete registry[name];\n  }\n};\n\nvar removeRegItem = function (obj, name, cb) {\n  var registry = getValidLE(obj).registry;\n\n  if (registry[name]) {\n    if (!cb) {\n      cleanRegistryForName(obj, name, true);\n    } else {\n      registry[name] = registry[name].filter(function (reg) {\n        return reg.cb !== cb;\n      });\n      cleanRegistryForName(obj, name);\n    }\n  }\n};\n\nfunction register(name, cb) {\n  return addRegistration(this, name, cb);\n}\n\nfunction registerOnce(name, cb) {\n  return addRegistration(this, name, cb, true);\n}\n\nfunction unregister(name, cb) {\n  removeRegItem(this, name, cb);\n}\n\nfunction getEvents() {\n  return getValidLE(this).events.slice();\n}\n\nfunction trigger(name) {\n  var _this = this;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var regs = findRegistrations(this, name);\n  var results;\n\n  if (regs.length) {\n    var _args$;\n\n    var packValue;\n\n    if (args.length === 1 && ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$[LE_PACK_SYM]) === true) {\n      //life-pack always returns array as params to spread\n      packValue = args[0].resolve();\n    }\n\n    results = regs.map(function (r) {\n      var result;\n\n      if (r.once) {\n        removeRegItem(_this, name, r.cb);\n      }\n\n      if (packValue) {\n        result = r.cb.apply(r, _toConsumableArray(packValue));\n      } else if (!args.length) {\n        result = r.cb();\n      } else if (args.length === 1) {\n        result = r.cb(args[0]);\n      } else if (args.length === 2) {\n        result = r.cb(args[0], args[1]);\n      } else if (args.length === 3) {\n        result = r.cb(args[0], args[1], args[2]);\n      } else {\n        result = r.cb.apply(r, args);\n      }\n\n      return result;\n    }).filter(function (result) {\n      return !isUndefined(result);\n    }).map(function (result) {\n      return isPromise(result) ? result : Promise.resolve(result);\n    });\n  }\n\n  return results && (results.length ? results : undefined);\n} //registry, events, stats become shared\n\n\nfunction assign(toObj) {\n  var le = getValidLE(this);\n  defineLifeData(toObj, le.options, le.events, le.registry, le.stats);\n  return createApi(toObj);\n}\n\nfunction addEvent(name) {\n  var le = getValidLE(this);\n\n  if (le.options.canAddEvents) {\n    var index = le.events.indexOf(name);\n\n    if (!~index) {\n      le.events.push(name);\n    } else {\n      throw new Error(\"Event '\".concat(name, \"' already defined\"));\n    }\n  } else {\n    throw new Error(\"Cannot add new events (canAddEvents = false)\");\n  }\n}\n\nfunction removeEvent(name) {\n  var le = getValidLE(this);\n\n  if (le.options.canRemoveEvents) {\n    var index = le.events.indexOf(name);\n    le.events.splice(index, 1);\n  } else {\n    throw new Error(\"Cannot remove events (canRemoveEvents = false)\");\n  }\n}\n\nfunction hasEvent(name) {\n  var le = getValidLE(this);\n  return !!~le.events.indexOf(name);\n}\n\nfunction hasEventRegistrations(name) {\n  return !!findRegistrations(this, name).length;\n} // function getStats(name?: any) {\n//\n// }\n\n\nvar defineLifeData = function (target, options) {\n  var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var registry = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var stats = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  Object.defineProperties(target, _objectSpread(_defineProperty({}, LESYM, {\n    value: Object.seal({\n      registry: registry,\n      events: events,\n      options: options,\n      stats: stats\n    })\n  }), getPublicMethods()));\n};\n\nvar addLife = function (target) {\n  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  target = target || {};\n  options = _objectSpread(_objectSpread({}, defaults), options);\n\n  if (!isLE(target)) {\n    defineLifeData(target, options, events);\n  }\n\n  return createApi(target);\n};\n\nexport default addLife;\nexport { isLE };","map":{"version":3,"sources":["C:/Users/lucki/Desktop/ClassCodeProjects/amtil-mc/node_modules/@rpldy/life-events/lib/esm/lifeEvents.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","Array","from","isArray","_arrayLikeToArray","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","prototype","toString","call","slice","constructor","name","test","len","arr2","_arr","_n","_d","_e","undefined","_i","_s","next","done","err","isPromise","defaults","validateFunction","isUndefined","LESYM","LE_PACK_SYM","getLE","getValidLE","le","Error","isLE","addRegistration","cb","once","options","allowRegisterNonExistent","events","indexOf","concat","namedRegistry","registry","find","r","unregister","findRegistrations","values","flat","publicMethods","register","registerOnce","getEvents","getPublicMethods","entries","reduce","res","_ref","_ref2","m","apiMethods","trigger","addEvent","removeEvent","hasEvent","hasEventRegistrations","assign","createApi","bind","cleanRegistryForName","force","removeRegItem","reg","_this","_len","args","_key","regs","results","_args$","packValue","resolve","map","result","Promise","toObj","defineLifeData","stats","canAddEvents","index","canRemoveEvents","splice","seal","addLife"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport isPromise from \"is-promise\";\nimport defaults from \"./defaults\";\nimport { validateFunction, isUndefined } from \"./utils\";\nimport { LESYM, LE_PACK_SYM } from \"./consts\";\n\n//TODO: implement STATS\nvar getLE = function (obj) {\n  return obj ? obj[LESYM] : null;\n};\n\nvar getValidLE = function (obj) {\n  var le = getLE(obj);\n\n  if (!le) {\n    throw new Error(\"Didnt find LE internal object. Something very bad happened!\");\n  }\n\n  return le;\n};\n\nvar isLE = function (obj) {\n  return !!getLE(obj);\n};\n\nvar addRegistration = function (obj, name, cb) {\n  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  validateFunction(cb, \"cb\");\n  var le = getValidLE(obj);\n\n  if (!le.options.allowRegisterNonExistent && !~le.events.indexOf(name)) {\n    throw new Error(\"Cannot register for event \".concat(name.toString(), \" that wasn't already defined (allowRegisterNonExistent = false)\"));\n  }\n\n  var namedRegistry = le.registry[name] || [];\n\n  if (!namedRegistry.find(function (r) {\n    return r.cb === cb;\n  })) {\n    //only add same callback for a name once\n    namedRegistry.push({\n      name: name,\n      cb: cb,\n      once: once\n    });\n    le.registry[name] = namedRegistry;\n  }\n\n  return function () {\n    return unregister.call(obj, name, cb);\n  };\n};\n\nvar findRegistrations = function (obj, name) {\n  var registry = getValidLE(obj).registry;\n  return name ? registry[name] ? registry[name].slice() : [] : // $FlowFixMe - flow doesnt know about Array.prototype.flat yet...\n  Object.values(registry).flat();\n};\n\nvar publicMethods = {\n  \"on\": register,\n  \"once\": registerOnce,\n  \"off\": unregister,\n  \"getEvents\": getEvents\n};\n\nvar getPublicMethods = function () {\n  return Object.entries(publicMethods).reduce(function (res, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        m = _ref2[1];\n\n    res[key] = {\n      value: m\n    };\n    return res;\n  }, {});\n}; //using string keys here because can't rely on function names to stay after (babel/webpack) build\n\n\nvar apiMethods = {\n  \"trigger\": trigger,\n  \"addEvent\": addEvent,\n  \"removeEvent\": removeEvent,\n  \"hasEvent\": hasEvent,\n  \"hasEventRegistrations\": hasEventRegistrations,\n  \"assign\": assign\n};\n\nvar createApi = function (target) {\n  return Object.keys(apiMethods).reduce(function (res, name) {\n    res[name] = apiMethods[name].bind(target);\n    return res;\n  }, _objectSpread({\n    target: target\n  }, apiMethods));\n};\n\nvar cleanRegistryForName = function (obj, name) {\n  var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var registry = getValidLE(obj).registry;\n\n  if (registry[name] && (force || !registry[name].length)) {\n    delete registry[name];\n  }\n};\n\nvar removeRegItem = function (obj, name, cb) {\n  var registry = getValidLE(obj).registry;\n\n  if (registry[name]) {\n    if (!cb) {\n      cleanRegistryForName(obj, name, true);\n    } else {\n      registry[name] = registry[name].filter(function (reg) {\n        return reg.cb !== cb;\n      });\n      cleanRegistryForName(obj, name);\n    }\n  }\n};\n\nfunction register(name, cb) {\n  return addRegistration(this, name, cb);\n}\n\nfunction registerOnce(name, cb) {\n  return addRegistration(this, name, cb, true);\n}\n\nfunction unregister(name, cb) {\n  removeRegItem(this, name, cb);\n}\n\nfunction getEvents() {\n  return getValidLE(this).events.slice();\n}\n\nfunction trigger(name) {\n  var _this = this;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var regs = findRegistrations(this, name);\n  var results;\n\n  if (regs.length) {\n    var _args$;\n\n    var packValue;\n\n    if (args.length === 1 && ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$[LE_PACK_SYM]) === true) {\n      //life-pack always returns array as params to spread\n      packValue = args[0].resolve();\n    }\n\n    results = regs.map(function (r) {\n      var result;\n\n      if (r.once) {\n        removeRegItem(_this, name, r.cb);\n      }\n\n      if (packValue) {\n        result = r.cb.apply(r, _toConsumableArray(packValue));\n      } else if (!args.length) {\n        result = r.cb();\n      } else if (args.length === 1) {\n        result = r.cb(args[0]);\n      } else if (args.length === 2) {\n        result = r.cb(args[0], args[1]);\n      } else if (args.length === 3) {\n        result = r.cb(args[0], args[1], args[2]);\n      } else {\n        result = r.cb.apply(r, args);\n      }\n\n      return result;\n    }).filter(function (result) {\n      return !isUndefined(result);\n    }).map(function (result) {\n      return isPromise(result) ? result : Promise.resolve(result);\n    });\n  }\n\n  return results && (results.length ? results : undefined);\n} //registry, events, stats become shared\n\n\nfunction assign(toObj) {\n  var le = getValidLE(this);\n  defineLifeData(toObj, le.options, le.events, le.registry, le.stats);\n  return createApi(toObj);\n}\n\nfunction addEvent(name) {\n  var le = getValidLE(this);\n\n  if (le.options.canAddEvents) {\n    var index = le.events.indexOf(name);\n\n    if (!~index) {\n      le.events.push(name);\n    } else {\n      throw new Error(\"Event '\".concat(name, \"' already defined\"));\n    }\n  } else {\n    throw new Error(\"Cannot add new events (canAddEvents = false)\");\n  }\n}\n\nfunction removeEvent(name) {\n  var le = getValidLE(this);\n\n  if (le.options.canRemoveEvents) {\n    var index = le.events.indexOf(name);\n    le.events.splice(index, 1);\n  } else {\n    throw new Error(\"Cannot remove events (canRemoveEvents = false)\");\n  }\n}\n\nfunction hasEvent(name) {\n  var le = getValidLE(this);\n  return !!~le.events.indexOf(name);\n}\n\nfunction hasEventRegistrations(name) {\n  return !!findRegistrations(this, name).length;\n} // function getStats(name?: any) {\n//\n// }\n\n\nvar defineLifeData = function (target, options) {\n  var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var registry = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var stats = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  Object.defineProperties(target, _objectSpread(_defineProperty({}, LESYM, {\n    value: Object.seal({\n      registry: registry,\n      events: events,\n      options: options,\n      stats: stats\n    })\n  }), getPublicMethods()));\n};\n\nvar addLife = function (target) {\n  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  target = target || {};\n  options = _objectSpread(_objectSpread({}, defaults), options);\n\n  if (!isLE(target)) {\n    defineLifeData(target, options, events);\n  }\n\n  return createApi(target);\n};\n\nexport default addLife;\nexport { isLE };"]},"metadata":{},"sourceType":"module"}