{"ast":null,"code":"var _FILE_STATE_TO_EVENT_;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS, ITEM_FINALIZE_STATES } from \"../consts\";\nimport { cleanUpFinishedBatches, incrementBatchFinishedCounter } from \"./batchHelpers\";\nexport var FILE_STATE_TO_EVENT_MAP = (_FILE_STATE_TO_EVENT_ = {}, _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.PENDING, null), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ADDED, UPLOADER_EVENTS.ITEM_START), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.FINISHED, UPLOADER_EVENTS.ITEM_FINISH), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ERROR, UPLOADER_EVENTS.ITEM_ERROR), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.CANCELLED, UPLOADER_EVENTS.ITEM_CANCEL), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ABORTED, UPLOADER_EVENTS.ITEM_ABORT), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.UPLOADING, UPLOADER_EVENTS.ITEM_PROGRESS), _FILE_STATE_TO_EVENT_);\n\nvar getIsFinalized = function (item) {\n  return !!~ITEM_FINALIZE_STATES.indexOf(item.state);\n};\n\nvar processFinishedRequest = function (queue, finishedData, next) {\n  finishedData.forEach(function (itemData) {\n    var state = queue.getState();\n    var id = itemData.id,\n        info = itemData.info;\n    logger.debugLog(\"uploader.processor.queue: request finished for item - \", {\n      id: id,\n      info: info\n    });\n\n    if (state.items[id]) {\n      queue.updateState(function (state) {\n        var item = state.items[id];\n        item.state = info.state;\n        item.uploadResponse = info.response;\n        item.uploadStatus = info.status;\n\n        if (getIsFinalized(item)) {\n          delete state.aborts[id];\n        }\n      }); //get most up-to-date item data\n\n      var item = queue.getState().items[id];\n\n      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {\n        //ensure we trigger progress event with completed = 100 for all items\n        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);\n      }\n\n      if (FILE_STATE_TO_EVENT_MAP[item.state]) {\n        //trigger UPLOADER EVENT for item based on its state\n        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);\n      }\n\n      if (getIsFinalized(item)) {\n        incrementBatchFinishedCounter(queue, item.batchId); //trigger FINALIZE event\n\n        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);\n      }\n    }\n\n    var index = state.itemQueue.indexOf(id);\n\n    if (~index) {\n      queue.updateState(function (state) {\n        state.itemQueue.splice(index, 1);\n        var activeIndex = state.activeIds.indexOf(id);\n\n        if (~activeIndex) {\n          state.activeIds.splice(activeIndex, 1);\n        }\n      });\n    }\n  }); //ensure finished batches are remove from state\n\n  cleanUpFinishedBatches(queue);\n  return next(queue);\n};\n\nexport default processFinishedRequest;","map":{"version":3,"sources":["C:/Users/lucki/Desktop/ClassCodeProjects/amtil-mc/node_modules/@rpldy/uploader/lib/esm/queue/processFinishedRequest.js"],"names":["_FILE_STATE_TO_EVENT_","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","FILE_STATES","logger","UPLOADER_EVENTS","ITEM_FINALIZE_STATES","cleanUpFinishedBatches","incrementBatchFinishedCounter","FILE_STATE_TO_EVENT_MAP","PENDING","ADDED","ITEM_START","FINISHED","ITEM_FINISH","ERROR","ITEM_ERROR","CANCELLED","ITEM_CANCEL","ABORTED","ITEM_ABORT","UPLOADING","ITEM_PROGRESS","getIsFinalized","item","indexOf","state","processFinishedRequest","queue","finishedData","next","forEach","itemData","getState","id","info","debugLog","items","updateState","uploadResponse","response","uploadStatus","status","aborts","completed","handleItemProgress","file","size","trigger","batchId","ITEM_FINALIZE","index","itemQueue","splice","activeIndex","activeIds"],"mappings":"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","sourcesContent":["var _FILE_STATE_TO_EVENT_;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS, ITEM_FINALIZE_STATES } from \"../consts\";\nimport { cleanUpFinishedBatches, incrementBatchFinishedCounter } from \"./batchHelpers\";\nexport var FILE_STATE_TO_EVENT_MAP = (_FILE_STATE_TO_EVENT_ = {}, _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.PENDING, null), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ADDED, UPLOADER_EVENTS.ITEM_START), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.FINISHED, UPLOADER_EVENTS.ITEM_FINISH), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ERROR, UPLOADER_EVENTS.ITEM_ERROR), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.CANCELLED, UPLOADER_EVENTS.ITEM_CANCEL), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ABORTED, UPLOADER_EVENTS.ITEM_ABORT), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.UPLOADING, UPLOADER_EVENTS.ITEM_PROGRESS), _FILE_STATE_TO_EVENT_);\n\nvar getIsFinalized = function (item) {\n  return !!~ITEM_FINALIZE_STATES.indexOf(item.state);\n};\n\nvar processFinishedRequest = function (queue, finishedData, next) {\n  finishedData.forEach(function (itemData) {\n    var state = queue.getState();\n    var id = itemData.id,\n        info = itemData.info;\n    logger.debugLog(\"uploader.processor.queue: request finished for item - \", {\n      id: id,\n      info: info\n    });\n\n    if (state.items[id]) {\n      queue.updateState(function (state) {\n        var item = state.items[id];\n        item.state = info.state;\n        item.uploadResponse = info.response;\n        item.uploadStatus = info.status;\n\n        if (getIsFinalized(item)) {\n          delete state.aborts[id];\n        }\n      }); //get most up-to-date item data\n\n      var item = queue.getState().items[id];\n\n      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {\n        //ensure we trigger progress event with completed = 100 for all items\n        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);\n      }\n\n      if (FILE_STATE_TO_EVENT_MAP[item.state]) {\n        //trigger UPLOADER EVENT for item based on its state\n        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);\n      }\n\n      if (getIsFinalized(item)) {\n        incrementBatchFinishedCounter(queue, item.batchId); //trigger FINALIZE event\n\n        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);\n      }\n    }\n\n    var index = state.itemQueue.indexOf(id);\n\n    if (~index) {\n      queue.updateState(function (state) {\n        state.itemQueue.splice(index, 1);\n        var activeIndex = state.activeIds.indexOf(id);\n\n        if (~activeIndex) {\n          state.activeIds.splice(activeIndex, 1);\n        }\n      });\n    }\n  }); //ensure finished batches are remove from state\n\n  cleanUpFinishedBatches(queue);\n  return next(queue);\n};\n\nexport default processFinishedRequest;"]},"metadata":{},"sourceType":"module"}