{"ast":null,"code":"var _ITEM_STATE_ABORTS;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { BATCH_STATES, FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { triggerUploaderBatchEvent, getBatchFromState, getIsBatchFinalized } from \"./batchHelpers\";\nimport processFinishedRequest from \"./processFinishedRequest\";\n\nvar abortNonUploadingItem = function (queue, item, next) {\n  logger.debugLog(\"uploader.queue: aborting \".concat(item.state, \" item  - \"), item); //manually finish request for item that hasnt reached the sender yet\n\n  processFinishedRequest(queue, [{\n    id: item.id,\n    info: {\n      status: 0,\n      state: FILE_STATES.ABORTED,\n      response: \"aborted\"\n    }\n  }], next);\n  return true;\n};\n\nvar ITEM_STATE_ABORTS = (_ITEM_STATE_ABORTS = {}, _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.UPLOADING, function (queue, item) {\n  logger.debugLog(\"uploader.queue: aborting uploading item  - \", item);\n  return queue.getState().aborts[item.id]();\n}), _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.ADDED, abortNonUploadingItem), _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.PENDING, abortNonUploadingItem), _ITEM_STATE_ABORTS);\n\nvar callAbortOnItem = function (queue, id, next) {\n  var state = queue.getState(),\n      item = state.items[id],\n      itemState = item === null || item === void 0 ? void 0 : item.state; //$FlowIssue[prop-missing]\n\n  return ITEM_STATE_ABORTS[itemState] ? //$FlowExpectedError[extra-arg]\n  //$FlowIssue[prop-missing]\n  ITEM_STATE_ABORTS[itemState](queue, item, next) : false;\n};\n\nvar abortAll = function (queue, next) {\n  var items = queue.getState().items;\n  Object.keys(items).forEach(function (id) {\n    return callAbortOnItem(queue, id, next);\n  });\n  queue.trigger(UPLOADER_EVENTS.ALL_ABORT);\n};\n\nvar abortItem = function (queue, id, next) {\n  return callAbortOnItem(queue, id, next);\n};\n\nvar abortBatch = function (queue, id, next) {\n  var state = queue.getState(),\n      batchData = state.batches[id],\n      batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;\n\n  if (batch && !getIsBatchFinalized(batch)) {\n    queue.updateState(function (state) {\n      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;\n    });\n    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);\n    batch.items.forEach(function (bi) {\n      return callAbortOnItem(queue, bi.id, next);\n    });\n  }\n};\n\nexport { abortAll, abortItem, abortBatch };","map":{"version":3,"sources":["C:/Users/lucki/Desktop/ClassCodeProjects/amtil-mc/node_modules/@rpldy/uploader/lib/esm/queue/abort.js"],"names":["_ITEM_STATE_ABORTS","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","BATCH_STATES","FILE_STATES","logger","UPLOADER_EVENTS","triggerUploaderBatchEvent","getBatchFromState","getIsBatchFinalized","processFinishedRequest","abortNonUploadingItem","queue","item","next","debugLog","concat","state","id","info","status","ABORTED","response","ITEM_STATE_ABORTS","UPLOADING","getState","aborts","ADDED","PENDING","callAbortOnItem","items","itemState","abortAll","keys","forEach","trigger","ALL_ABORT","abortItem","abortBatch","batchData","batches","batch","updateState","BATCH_ABORT","bi"],"mappings":"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","sourcesContent":["var _ITEM_STATE_ABORTS;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { BATCH_STATES, FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { triggerUploaderBatchEvent, getBatchFromState, getIsBatchFinalized } from \"./batchHelpers\";\nimport processFinishedRequest from \"./processFinishedRequest\";\n\nvar abortNonUploadingItem = function (queue, item, next) {\n  logger.debugLog(\"uploader.queue: aborting \".concat(item.state, \" item  - \"), item); //manually finish request for item that hasnt reached the sender yet\n\n  processFinishedRequest(queue, [{\n    id: item.id,\n    info: {\n      status: 0,\n      state: FILE_STATES.ABORTED,\n      response: \"aborted\"\n    }\n  }], next);\n  return true;\n};\n\nvar ITEM_STATE_ABORTS = (_ITEM_STATE_ABORTS = {}, _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.UPLOADING, function (queue, item) {\n  logger.debugLog(\"uploader.queue: aborting uploading item  - \", item);\n  return queue.getState().aborts[item.id]();\n}), _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.ADDED, abortNonUploadingItem), _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.PENDING, abortNonUploadingItem), _ITEM_STATE_ABORTS);\n\nvar callAbortOnItem = function (queue, id, next) {\n  var state = queue.getState(),\n      item = state.items[id],\n      itemState = item === null || item === void 0 ? void 0 : item.state; //$FlowIssue[prop-missing]\n\n  return ITEM_STATE_ABORTS[itemState] ? //$FlowExpectedError[extra-arg]\n  //$FlowIssue[prop-missing]\n  ITEM_STATE_ABORTS[itemState](queue, item, next) : false;\n};\n\nvar abortAll = function (queue, next) {\n  var items = queue.getState().items;\n  Object.keys(items).forEach(function (id) {\n    return callAbortOnItem(queue, id, next);\n  });\n  queue.trigger(UPLOADER_EVENTS.ALL_ABORT);\n};\n\nvar abortItem = function (queue, id, next) {\n  return callAbortOnItem(queue, id, next);\n};\n\nvar abortBatch = function (queue, id, next) {\n  var state = queue.getState(),\n      batchData = state.batches[id],\n      batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;\n\n  if (batch && !getIsBatchFinalized(batch)) {\n    queue.updateState(function (state) {\n      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;\n    });\n    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);\n    batch.items.forEach(function (bi) {\n      return callAbortOnItem(queue, bi.id, next);\n    });\n  }\n};\n\nexport { abortAll, abortItem, abortBatch };"]},"metadata":{},"sourceType":"module"}