{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { BATCH_STATES, logger, merge, FILE_STATES } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nvar BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\nvar BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED];\n\nvar getBatchFromState = function (state, id) {\n  return state.batches[id].batch;\n};\n\nvar getBatch = function (queue, id) {\n  return getBatchFromState(queue.getState(), id);\n};\n\nvar isItemBelongsToBatch = function (queue, itemId, batchId) {\n  return queue.getState().items[itemId].batchId === batchId;\n};\n\nvar getBatchDataFromItemId = function (queue, itemId) {\n  var state = queue.getState();\n  var item = state.items[itemId];\n  return state.batches[item.batchId];\n};\n\nvar getBatchFromItemId = function (queue, itemId) {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\n\nvar removeBatchItems = function (queue, batchId) {\n  var batch = getBatch(queue, batchId);\n  queue.updateState(function (state) {\n    batch.items.forEach(function (_ref) {\n      var id = _ref.id;\n      delete state.items[id];\n      var index = state.itemQueue.indexOf(id);\n\n      if (~index) {\n        state.itemQueue.splice(index, 1);\n      }\n    });\n  });\n};\n\nvar removeBatch = function (queue, batchId) {\n  queue.updateState(function (state) {\n    delete state.batches[batchId];\n  });\n};\n\nvar cancelBatchForItem = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId),\n      batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.batchHelpers: cancelling batch: \", {\n    batch: batch\n  });\n  queue.updateState(function (state) {\n    var batch = getBatchFromState(state, batchId);\n    batch.state = BATCH_STATES.CANCELLED;\n  });\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\n\nvar isNewBatchStarting = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\n\nvar loadNewBatchForItem = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(function (isCancelled) {\n    if (!isCancelled) {\n      queue.updateState(function (state) {\n        state.currentBatch = batch.id;\n      });\n    }\n\n    return !isCancelled;\n  });\n};\n\nvar cleanUpFinishedBatches = function (queue) {\n  //TODO: schedule clean up on requestAnimationFrame\n  var state = queue.getState();\n  Object.keys(state.batches).forEach(function (batchId) {\n    var _state$batches$batchI = state.batches[batchId],\n        batch = _state$batches$batchI.batch,\n        finishedCounter = _state$batches$batchI.finishedCounter;\n    var orgItemCount = batch.orgItemCount; //shouldnt be the case, but if wasnt cleaned before, it will now\n\n    var alreadyFinalized = getIsBatchFinalized(batch);\n\n    if (orgItemCount === finishedCounter) {\n      queue.updateState(function (state) {\n        var batch = getBatchFromState(state, batchId); //set batch state to FINISHED before triggering event and removing it from queue\n\n        batch.state = alreadyFinalized ? batch.state : BATCH_STATES.FINISHED;\n\n        if (state.currentBatch === batchId) {\n          state.currentBatch = null;\n        }\n      });\n      logger.debugLog(\"uploady.uploader.batchHelpers: cleaning up batch: \".concat(batch.id));\n\n      if (!alreadyFinalized) {\n        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n      }\n\n      removeBatchItems(queue, batchId);\n      removeBatch(queue, batchId);\n    }\n  });\n};\n\nvar triggerUploaderBatchEvent = function (queue, batchId, event) {\n  var state = queue.getState(),\n      batch = getBatchFromState(state, batchId),\n      //get the most uptodate batch data\n  stateItems = state.items;\n\n  var eventBatch = _objectSpread(_objectSpread({}, unwrap(batch)), {}, {\n    items: batch.items.map(function (_ref2) {\n      var id = _ref2.id;\n      return unwrap(stateItems[id]);\n    })\n  });\n\n  queue.trigger(event, eventBatch);\n};\n\nvar getIsItemBatchReady = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\n\nvar detachRecycledFromPreviousBatch = function (queue, item) {\n  var previousBatch = item.previousBatch;\n\n  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {\n    var _getBatchFromItemId = getBatchFromItemId(queue, item.id),\n        batchId = _getBatchFromItemId.id;\n\n    if (batchId === previousBatch) {\n      queue.updateState(function (state) {\n        var batch = getBatchFromState(state, batchId);\n        var index = batch.items.findIndex(function (_ref3) {\n          var id = _ref3.id;\n          return id === item.id;\n        });\n\n        if (~index) {\n          batch.items.splice(index, 1);\n        }\n      });\n    }\n  }\n};\n\nvar preparePendingForUpload = function (queue, uploadOptions) {\n  queue.updateState(function (state) {\n    //remove pending state from pending batches\n    Object.keys(state.batches).forEach(function (batchId) {\n      var batchData = state.batches[batchId];\n      var batch = batchData.batch,\n          batchOptions = batchData.batchOptions;\n\n      if (batch.state === BATCH_STATES.PENDING) {\n        batch.items.forEach(function (item) {\n          item.state = FILE_STATES.ADDED;\n        });\n        batch.state = BATCH_STATES.ADDED;\n        batchData.batchOptions = merge({}, batchOptions, uploadOptions);\n      }\n    });\n  });\n};\n\nvar removePendingBatches = function (queue) {\n  var batches = queue.getState().batches;\n  Object.keys(batches).filter(function (batchId) {\n    return batches[batchId].batch.state === BATCH_STATES.PENDING;\n  }).forEach(function (batchId) {\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  });\n};\n\nvar incrementBatchFinishedCounter = function (queue, batchId) {\n  queue.updateState(function (state) {\n    state.batches[batchId].finishedCounter += 1;\n  });\n};\n\nvar getIsBatchFinalized = function (batch) {\n  return BATCH_FINISHED_STATES.includes(batch.state);\n};\n\nexport { loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized };","map":{"version":3,"sources":["C:/Users/lucki/Desktop/ClassCodeProjects/amtil-mc/node_modules/@rpldy/uploader/lib/esm/queue/batchHelpers.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","BATCH_STATES","logger","merge","FILE_STATES","unwrap","UPLOADER_EVENTS","BATCH_READY_STATES","ADDED","PROCESSING","UPLOADING","BATCH_FINISHED_STATES","ABORTED","CANCELLED","FINISHED","getBatchFromState","state","id","batches","batch","getBatch","queue","getState","isItemBelongsToBatch","itemId","batchId","items","getBatchDataFromItemId","item","getBatchFromItemId","removeBatchItems","updateState","_ref","index","itemQueue","indexOf","splice","removeBatch","cancelBatchForItem","debugLog","triggerUploaderBatchEvent","BATCH_CANCEL","isNewBatchStarting","currentBatch","loadNewBatchForItem","runCancellable","BATCH_START","then","isCancelled","cleanUpFinishedBatches","_state$batches$batchI","finishedCounter","orgItemCount","alreadyFinalized","getIsBatchFinalized","concat","BATCH_FINISH","event","stateItems","eventBatch","map","_ref2","trigger","getIsItemBatchReady","includes","detachRecycledFromPreviousBatch","previousBatch","recycled","_getBatchFromItemId","findIndex","_ref3","preparePendingForUpload","uploadOptions","batchData","batchOptions","PENDING","removePendingBatches","incrementBatchFinishedCounter"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { BATCH_STATES, logger, merge, FILE_STATES } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nvar BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\nvar BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED];\n\nvar getBatchFromState = function (state, id) {\n  return state.batches[id].batch;\n};\n\nvar getBatch = function (queue, id) {\n  return getBatchFromState(queue.getState(), id);\n};\n\nvar isItemBelongsToBatch = function (queue, itemId, batchId) {\n  return queue.getState().items[itemId].batchId === batchId;\n};\n\nvar getBatchDataFromItemId = function (queue, itemId) {\n  var state = queue.getState();\n  var item = state.items[itemId];\n  return state.batches[item.batchId];\n};\n\nvar getBatchFromItemId = function (queue, itemId) {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\n\nvar removeBatchItems = function (queue, batchId) {\n  var batch = getBatch(queue, batchId);\n  queue.updateState(function (state) {\n    batch.items.forEach(function (_ref) {\n      var id = _ref.id;\n      delete state.items[id];\n      var index = state.itemQueue.indexOf(id);\n\n      if (~index) {\n        state.itemQueue.splice(index, 1);\n      }\n    });\n  });\n};\n\nvar removeBatch = function (queue, batchId) {\n  queue.updateState(function (state) {\n    delete state.batches[batchId];\n  });\n};\n\nvar cancelBatchForItem = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId),\n      batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.batchHelpers: cancelling batch: \", {\n    batch: batch\n  });\n  queue.updateState(function (state) {\n    var batch = getBatchFromState(state, batchId);\n    batch.state = BATCH_STATES.CANCELLED;\n  });\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\n\nvar isNewBatchStarting = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\n\nvar loadNewBatchForItem = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(function (isCancelled) {\n    if (!isCancelled) {\n      queue.updateState(function (state) {\n        state.currentBatch = batch.id;\n      });\n    }\n\n    return !isCancelled;\n  });\n};\n\nvar cleanUpFinishedBatches = function (queue) {\n  //TODO: schedule clean up on requestAnimationFrame\n  var state = queue.getState();\n  Object.keys(state.batches).forEach(function (batchId) {\n    var _state$batches$batchI = state.batches[batchId],\n        batch = _state$batches$batchI.batch,\n        finishedCounter = _state$batches$batchI.finishedCounter;\n    var orgItemCount = batch.orgItemCount; //shouldnt be the case, but if wasnt cleaned before, it will now\n\n    var alreadyFinalized = getIsBatchFinalized(batch);\n\n    if (orgItemCount === finishedCounter) {\n      queue.updateState(function (state) {\n        var batch = getBatchFromState(state, batchId); //set batch state to FINISHED before triggering event and removing it from queue\n\n        batch.state = alreadyFinalized ? batch.state : BATCH_STATES.FINISHED;\n\n        if (state.currentBatch === batchId) {\n          state.currentBatch = null;\n        }\n      });\n      logger.debugLog(\"uploady.uploader.batchHelpers: cleaning up batch: \".concat(batch.id));\n\n      if (!alreadyFinalized) {\n        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n      }\n\n      removeBatchItems(queue, batchId);\n      removeBatch(queue, batchId);\n    }\n  });\n};\n\nvar triggerUploaderBatchEvent = function (queue, batchId, event) {\n  var state = queue.getState(),\n      batch = getBatchFromState(state, batchId),\n      //get the most uptodate batch data\n  stateItems = state.items;\n\n  var eventBatch = _objectSpread(_objectSpread({}, unwrap(batch)), {}, {\n    items: batch.items.map(function (_ref2) {\n      var id = _ref2.id;\n      return unwrap(stateItems[id]);\n    })\n  });\n\n  queue.trigger(event, eventBatch);\n};\n\nvar getIsItemBatchReady = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\n\nvar detachRecycledFromPreviousBatch = function (queue, item) {\n  var previousBatch = item.previousBatch;\n\n  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {\n    var _getBatchFromItemId = getBatchFromItemId(queue, item.id),\n        batchId = _getBatchFromItemId.id;\n\n    if (batchId === previousBatch) {\n      queue.updateState(function (state) {\n        var batch = getBatchFromState(state, batchId);\n        var index = batch.items.findIndex(function (_ref3) {\n          var id = _ref3.id;\n          return id === item.id;\n        });\n\n        if (~index) {\n          batch.items.splice(index, 1);\n        }\n      });\n    }\n  }\n};\n\nvar preparePendingForUpload = function (queue, uploadOptions) {\n  queue.updateState(function (state) {\n    //remove pending state from pending batches\n    Object.keys(state.batches).forEach(function (batchId) {\n      var batchData = state.batches[batchId];\n      var batch = batchData.batch,\n          batchOptions = batchData.batchOptions;\n\n      if (batch.state === BATCH_STATES.PENDING) {\n        batch.items.forEach(function (item) {\n          item.state = FILE_STATES.ADDED;\n        });\n        batch.state = BATCH_STATES.ADDED;\n        batchData.batchOptions = merge({}, batchOptions, uploadOptions);\n      }\n    });\n  });\n};\n\nvar removePendingBatches = function (queue) {\n  var batches = queue.getState().batches;\n  Object.keys(batches).filter(function (batchId) {\n    return batches[batchId].batch.state === BATCH_STATES.PENDING;\n  }).forEach(function (batchId) {\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  });\n};\n\nvar incrementBatchFinishedCounter = function (queue, batchId) {\n  queue.updateState(function (state) {\n    state.batches[batchId].finishedCounter += 1;\n  });\n};\n\nvar getIsBatchFinalized = function (batch) {\n  return BATCH_FINISHED_STATES.includes(batch.state);\n};\n\nexport { loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized };"]},"metadata":{},"sourceType":"module"}