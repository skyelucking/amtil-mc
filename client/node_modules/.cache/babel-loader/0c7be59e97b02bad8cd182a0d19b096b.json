{"ast":null,"code":"import { triggerUpdater, isSamePropInArrays, FILE_STATES, logger, getMerge } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport processFinishedRequest from \"./processFinishedRequest\";\nvar mergeWithUndefined = getMerge({\n  undefinedOverwrites: true\n});\n\nvar triggerPreSendUpdate = function (queue, items, options) {\n  return triggerUpdater(queue.trigger, UPLOADER_EVENTS.REQUEST_PRE_SEND, {\n    items: items,\n    options: options\n  }) // $FlowFixMe - https://github.com/facebook/flow/issues/8215\n  .then(function (updated) {\n    if (updated) {\n      logger.debugLog(\"uploader.queue: REQUEST_PRE_SEND event returned updated items/options\", updated);\n\n      if (updated.items) {\n        //can't change items count at this point.\n        if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, [\"id\", \"batchId\", \"recycled\"])) {\n          throw new Error(\"REQUEST_PRE_SEND event handlers must return same items with same ids\");\n        }\n\n        items = updated.items;\n      }\n\n      if (updated.options) {\n        options = mergeWithUndefined({}, options, updated.options);\n      }\n    }\n\n    return {\n      items: items,\n      options: options,\n      cancelled: updated === false\n    };\n  });\n};\n\nvar prepareAllowedItems = function (queue, items) {\n  var allowedIds = items.map(function (item) {\n    return item.id;\n  });\n  queue.updateState(function (state) {\n    state.activeIds = state.activeIds.concat(allowedIds);\n  });\n  return triggerPreSendUpdate(queue, items, queue.getState().batches[items[0].batchId].batchOptions).then(function (prepared) {\n    if (!prepared.cancelled) {\n      //update potentially changed data back into queue state\n      queue.updateState(function (state) {\n        prepared.items.forEach(function (i) {\n          state.items[i.id] = i;\n        });\n        state.batches[items[0].batchId].batchOptions = prepared.options;\n      }); //use objects from internal state(proxies) - not objects from userland\n\n      var updatedState = queue.getState();\n      prepared.items = prepared.items.map(function (item) {\n        return updatedState.items[item.id];\n      });\n      prepared.options = updatedState.batches[items[0].batchId].batchOptions;\n    }\n\n    return prepared;\n  });\n};\n\nvar updateUploadingState = function (queue, items, sendResult) {\n  queue.updateState(function (state) {\n    items.forEach(function (bi) {\n      var item = state.items[bi.id];\n      item.state = FILE_STATES.UPLOADING;\n      state.aborts[bi.id] = sendResult.abort;\n    });\n  });\n};\n\nvar sendAllowedItems = function (queue, itemsSendData, next) {\n  var items = itemsSendData.items,\n      options = itemsSendData.options;\n  var batch = queue.getState().batches[items[0].batchId].batch;\n  var sendResult;\n\n  try {\n    sendResult = queue.sender.send(items, batch, options);\n  } catch (ex) {\n    logger.debugLog(\"uploader.queue: sender failed with unexpected error\", ex); //provide error result so file(s) are marked as failed\n\n    sendResult = {\n      request: Promise.resolve({\n        status: 0,\n        state: FILE_STATES.ERROR,\n        response: ex.message\n      }),\n      abort: function abort() {\n        return false;\n      },\n      senderType: \"exception-handler\"\n    };\n  }\n\n  var _sendResult = sendResult,\n      request = _sendResult.request;\n  updateUploadingState(queue, items, sendResult);\n  return request //wait for server request to return\n  .then(function (requestInfo) {\n    var finishedData = items.map(function (item) {\n      return {\n        id: item.id,\n        info: requestInfo\n      };\n    });\n    processFinishedRequest(queue, finishedData, next);\n  });\n};\n\nvar reportCancelledItems = function (queue, items, cancelledResults, next) {\n  var cancelledItemsIds = cancelledResults.map(function (isCancelled, index) {\n    return isCancelled ? items[index].id : null;\n  }).filter(Boolean);\n\n  if (cancelledItemsIds.length) {\n    var finishedData = cancelledItemsIds.map(function (id) {\n      return {\n        id: id,\n        info: {\n          status: 0,\n          state: FILE_STATES.CANCELLED,\n          response: \"cancel\"\n        }\n      };\n    });\n    processFinishedRequest(queue, finishedData, next); //report about cancelled items\n  }\n\n  return !!cancelledItemsIds.length;\n}; //make sure item is still pending. Something might have changed while waiting for ITEM_START handling. Maybe someone called abort...\n\n\nvar getAllowedItem = function (id, queue) {\n  return queue.getState().items[id];\n}; //send group of items to be uploaded\n\n\nvar processBatchItems = function (queue, ids, next) {\n  var state = queue.getState(); //ids will have more than one when grouping is allowed\n\n  var items = Object.values(state.items);\n  items = items.filter(function (item) {\n    return !!~ids.indexOf(item.id);\n  }); //allow user code cancel items from start event handler(s)\n\n  return Promise.all(items.map(function (i) {\n    return queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i);\n  })).then(function (cancelledResults) {\n    var allowedItems = cancelledResults.map(function (isCancelled, index) {\n      return isCancelled ? null : getAllowedItem(items[index].id, queue);\n    }).filter(Boolean);\n    return {\n      allowedItems: allowedItems,\n      cancelledResults: cancelledResults\n    };\n  }).then(function (_ref) {\n    var allowedItems = _ref.allowedItems,\n        cancelledResults = _ref.cancelledResults;\n    var afterPreparePromise = allowedItems.length ? prepareAllowedItems(queue, allowedItems).then() : Promise.resolve();\n    return afterPreparePromise.then(function (itemsSendData) {\n      var nextP;\n\n      if (itemsSendData) {\n        if (itemsSendData.cancelled) {\n          cancelledResults = ids.map(function () {\n            return true;\n          });\n        } else {\n          //we dont need to wait for the response here\n          sendAllowedItems(queue, itemsSendData, next);\n        }\n      } //if no cancelled we can go to process more items immediately (and not wait for upload responses)\n\n\n      if (!reportCancelledItems(queue, items, cancelledResults, next)) {\n        nextP = next(queue); //when concurrent is allowed, we can go ahead and process more\n      }\n\n      return nextP;\n    });\n  });\n};\n\nexport default processBatchItems;","map":{"version":3,"sources":["C:/Users/lucki/Desktop/ClassCodeProjects/amtil-mc/node_modules/@rpldy/uploader/lib/esm/queue/processBatchItems.js"],"names":["triggerUpdater","isSamePropInArrays","FILE_STATES","logger","getMerge","UPLOADER_EVENTS","processFinishedRequest","mergeWithUndefined","undefinedOverwrites","triggerPreSendUpdate","queue","items","options","trigger","REQUEST_PRE_SEND","then","updated","debugLog","length","Error","cancelled","prepareAllowedItems","allowedIds","map","item","id","updateState","state","activeIds","concat","getState","batches","batchId","batchOptions","prepared","forEach","i","updatedState","updateUploadingState","sendResult","bi","UPLOADING","aborts","abort","sendAllowedItems","itemsSendData","next","batch","sender","send","ex","request","Promise","resolve","status","ERROR","response","message","senderType","_sendResult","requestInfo","finishedData","info","reportCancelledItems","cancelledResults","cancelledItemsIds","isCancelled","index","filter","Boolean","CANCELLED","getAllowedItem","processBatchItems","ids","Object","values","indexOf","all","runCancellable","ITEM_START","allowedItems","_ref","afterPreparePromise","nextP"],"mappings":"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","sourcesContent":["import { triggerUpdater, isSamePropInArrays, FILE_STATES, logger, getMerge } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport processFinishedRequest from \"./processFinishedRequest\";\nvar mergeWithUndefined = getMerge({\n  undefinedOverwrites: true\n});\n\nvar triggerPreSendUpdate = function (queue, items, options) {\n  return triggerUpdater(queue.trigger, UPLOADER_EVENTS.REQUEST_PRE_SEND, {\n    items: items,\n    options: options\n  }) // $FlowFixMe - https://github.com/facebook/flow/issues/8215\n  .then(function (updated) {\n    if (updated) {\n      logger.debugLog(\"uploader.queue: REQUEST_PRE_SEND event returned updated items/options\", updated);\n\n      if (updated.items) {\n        //can't change items count at this point.\n        if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, [\"id\", \"batchId\", \"recycled\"])) {\n          throw new Error(\"REQUEST_PRE_SEND event handlers must return same items with same ids\");\n        }\n\n        items = updated.items;\n      }\n\n      if (updated.options) {\n        options = mergeWithUndefined({}, options, updated.options);\n      }\n    }\n\n    return {\n      items: items,\n      options: options,\n      cancelled: updated === false\n    };\n  });\n};\n\nvar prepareAllowedItems = function (queue, items) {\n  var allowedIds = items.map(function (item) {\n    return item.id;\n  });\n  queue.updateState(function (state) {\n    state.activeIds = state.activeIds.concat(allowedIds);\n  });\n  return triggerPreSendUpdate(queue, items, queue.getState().batches[items[0].batchId].batchOptions).then(function (prepared) {\n    if (!prepared.cancelled) {\n      //update potentially changed data back into queue state\n      queue.updateState(function (state) {\n        prepared.items.forEach(function (i) {\n          state.items[i.id] = i;\n        });\n        state.batches[items[0].batchId].batchOptions = prepared.options;\n      }); //use objects from internal state(proxies) - not objects from userland\n\n      var updatedState = queue.getState();\n      prepared.items = prepared.items.map(function (item) {\n        return updatedState.items[item.id];\n      });\n      prepared.options = updatedState.batches[items[0].batchId].batchOptions;\n    }\n\n    return prepared;\n  });\n};\n\nvar updateUploadingState = function (queue, items, sendResult) {\n  queue.updateState(function (state) {\n    items.forEach(function (bi) {\n      var item = state.items[bi.id];\n      item.state = FILE_STATES.UPLOADING;\n      state.aborts[bi.id] = sendResult.abort;\n    });\n  });\n};\n\nvar sendAllowedItems = function (queue, itemsSendData, next) {\n  var items = itemsSendData.items,\n      options = itemsSendData.options;\n  var batch = queue.getState().batches[items[0].batchId].batch;\n  var sendResult;\n\n  try {\n    sendResult = queue.sender.send(items, batch, options);\n  } catch (ex) {\n    logger.debugLog(\"uploader.queue: sender failed with unexpected error\", ex); //provide error result so file(s) are marked as failed\n\n    sendResult = {\n      request: Promise.resolve({\n        status: 0,\n        state: FILE_STATES.ERROR,\n        response: ex.message\n      }),\n      abort: function abort() {\n        return false;\n      },\n      senderType: \"exception-handler\"\n    };\n  }\n\n  var _sendResult = sendResult,\n      request = _sendResult.request;\n  updateUploadingState(queue, items, sendResult);\n  return request //wait for server request to return\n  .then(function (requestInfo) {\n    var finishedData = items.map(function (item) {\n      return {\n        id: item.id,\n        info: requestInfo\n      };\n    });\n    processFinishedRequest(queue, finishedData, next);\n  });\n};\n\nvar reportCancelledItems = function (queue, items, cancelledResults, next) {\n  var cancelledItemsIds = cancelledResults.map(function (isCancelled, index) {\n    return isCancelled ? items[index].id : null;\n  }).filter(Boolean);\n\n  if (cancelledItemsIds.length) {\n    var finishedData = cancelledItemsIds.map(function (id) {\n      return {\n        id: id,\n        info: {\n          status: 0,\n          state: FILE_STATES.CANCELLED,\n          response: \"cancel\"\n        }\n      };\n    });\n    processFinishedRequest(queue, finishedData, next); //report about cancelled items\n  }\n\n  return !!cancelledItemsIds.length;\n}; //make sure item is still pending. Something might have changed while waiting for ITEM_START handling. Maybe someone called abort...\n\n\nvar getAllowedItem = function (id, queue) {\n  return queue.getState().items[id];\n}; //send group of items to be uploaded\n\n\nvar processBatchItems = function (queue, ids, next) {\n  var state = queue.getState(); //ids will have more than one when grouping is allowed\n\n  var items = Object.values(state.items);\n  items = items.filter(function (item) {\n    return !!~ids.indexOf(item.id);\n  }); //allow user code cancel items from start event handler(s)\n\n  return Promise.all(items.map(function (i) {\n    return queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i);\n  })).then(function (cancelledResults) {\n    var allowedItems = cancelledResults.map(function (isCancelled, index) {\n      return isCancelled ? null : getAllowedItem(items[index].id, queue);\n    }).filter(Boolean);\n    return {\n      allowedItems: allowedItems,\n      cancelledResults: cancelledResults\n    };\n  }).then(function (_ref) {\n    var allowedItems = _ref.allowedItems,\n        cancelledResults = _ref.cancelledResults;\n    var afterPreparePromise = allowedItems.length ? prepareAllowedItems(queue, allowedItems).then() : Promise.resolve();\n    return afterPreparePromise.then(function (itemsSendData) {\n      var nextP;\n\n      if (itemsSendData) {\n        if (itemsSendData.cancelled) {\n          cancelledResults = ids.map(function () {\n            return true;\n          });\n        } else {\n          //we dont need to wait for the response here\n          sendAllowedItems(queue, itemsSendData, next);\n        }\n      } //if no cancelled we can go to process more items immediately (and not wait for upload responses)\n\n\n      if (!reportCancelledItems(queue, items, cancelledResults, next)) {\n        nextP = next(queue); //when concurrent is allowed, we can go ahead and process more\n      }\n\n      return nextP;\n    });\n  });\n};\n\nexport default processBatchItems;"]},"metadata":{},"sourceType":"module"}